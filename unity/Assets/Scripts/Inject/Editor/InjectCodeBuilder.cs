using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Security.Cryptography;
using System.Text;
using UnityEditor;
using UnityEngine;

// ========== コード生成用のエディタスクリプト ==========
#if UNITY_EDITOR

public static class DICodeGenerator
{
    private const string GENERATED_CODE_PATH = "Assets/Scripts/Inject/Generated/";
    private const string INJECT_PARAM_LIST_FILE_NAME = "InjectParamListParams.cs";
    private const string SETTINGS_PATH = "Assets/DataAsset/Params/ParamInjectSettings.asset";

    [MenuItem("Tools/DI/Generate Injection Code")]
    public static void GenerateInjectionCode()
    {
        // 設定ファイルをロード
        var settings = LoadSettings();
        string outputPath = settings?.GeneratedCodePath ?? GENERATED_CODE_PATH;
        
        // 出力ディレクトリを作成
        if (!Directory.Exists(outputPath))
        {
            Directory.CreateDirectory(outputPath);
        }

        // 全てのアセンブリからInjectアトリビュートのあるクラスを検索
        var types = FindInjectableTypes();

        // 各クラスに対して個別のファイルを生成
        int generatedCount = 0;
        foreach (var type in types)
        {
            if (GenerateInjectParamsFileForType(outputPath, type))
            {
                generatedCount++;
            }
        }

        // InjectParamListのPartial Classを生成
        bool paramListGenerated = GenerateInjectParamListPartialClass(outputPath, settings, types);
        if (paramListGenerated)
        {
            generatedCount++;
        }

        if (generatedCount > 0)
        {
            AssetDatabase.Refresh();
            Debug.Log($"Generated {generatedCount} injection files (out of {types.Count + 1} total) in {outputPath}");
        }
        else
        {
            Debug.Log("No injection files changed, generation skipped.");
        }
    }

    /// <summary>
    /// 設定ファイルをロード
    /// </summary>
    private static ParamInjectSettings LoadSettings()
    {
        return AssetDatabase.LoadAssetAtPath<ParamInjectSettings>(SETTINGS_PATH);
    }

    /// <summary>
    /// 個別クラス用のInjectParamsファイルを生成
    /// </summary>
    /// <returns>ファイルが生成された場合はtrue、スキップされた場合はfalse</returns>
    private static bool GenerateInjectParamsFileForType(string outputPath, Type type)
    {
        var sb = new StringBuilder();

        // 必要なusing句を収集
        var requiredNamespaces = new HashSet<string>();
        requiredNamespaces.Add("UnityEngine");
        requiredNamespaces.Add("System.Collections.Generic");

        // フィールドの型から必要なnamespaceを収集
        var ns_fields = type.GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
        foreach (var field in ns_fields)
        {
            var injectAttr = field.GetCustomAttribute<InjectAttribute>();
            if (injectAttr != null)
            {
                CollectRequiredNamespaces(field.FieldType, requiredNamespaces);
            }
        }

        // ヘッダー
        sb.AppendLine("// ========== AUTO GENERATED CODE ==========");
        sb.AppendLine("// Generated at: " + DateTime.Now);
        sb.AppendLine("// DO NOT EDIT THIS FILE MANUALLY");
        sb.AppendLine();

        // using句を追加
        foreach (var ns in requiredNamespaces.OrderBy(x => x))
        {
            sb.AppendLine($"using {ns};");
        }
        sb.AppendLine();

        string className = type.Name;
        string namespaceName = type.Namespace;

        // partial classとして生成
        if (!string.IsNullOrEmpty(namespaceName))
        {
            sb.AppendLine($"namespace {namespaceName}");
            sb.AppendLine("{");
        }

        sb.AppendLine($"    public partial class {className} : IInjectable");
        sb.AppendLine("    {");
        sb.AppendLine("        public virtual void InjectDependencies()");
        sb.AppendLine("        {");
        sb.AppendLine("            // パラメータ注入処理");
        sb.AppendLine("            var injectSystem = InjectSystem.Instance;");
        sb.AppendLine("            if (injectSystem == null || injectSystem.ParamInjectSettings == null)");
        sb.AppendLine("            {");
        sb.AppendLine($"                UnityEngine.Debug.LogError(\"InjectSystem or ParamInjectSettings not found for {className}\");");
        sb.AppendLine("                return;");
        sb.AppendLine("            }");
        sb.AppendLine();
        sb.AppendLine("            // InjectParamListから直接アクセス");
        sb.AppendLine("            var paramList = injectSystem.ParamInjectSettings.SelectedParamList;");
        sb.AppendLine("            if (paramList == null)");
        sb.AppendLine("            {");
        sb.AppendLine($"                UnityEngine.Debug.Log(\"InjectParamList not found for {className}. Set as original param. \");");
        sb.AppendLine("                return;");
        sb.AppendLine("            }");
        sb.AppendLine();

        // フィールドごとに注入コードを生成
        var fields = type.GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
        foreach (var field in fields)
        {
            var injectAttr = field.GetCustomAttribute<InjectAttribute>();
            if (injectAttr != null)
            {
                string key = injectAttr.Key ?? field.Name;
                if (string.IsNullOrEmpty(injectAttr.Key) && key.StartsWith("_"))
                {
                    key = key.Substring(1);
                }

                string fieldName = field.Name;
                string typeName = GetTypeName(field.FieldType);

                string propertyName = ToUpperCamelCase(key);
                sb.AppendLine($"            // Inject {fieldName} (key: {key}, type: {typeName})");
                sb.AppendLine($"            this.{fieldName} = paramList.{propertyName};");
                sb.AppendLine($"            UnityEngine.Debug.Log($\"Injected {fieldName} = {{paramList.{propertyName}}} in {className}\");");
                sb.AppendLine();
            }
        }

        sb.AppendLine("        }");
        sb.AppendLine("    }");

        if (!string.IsNullOrEmpty(namespaceName))
        {
            sb.AppendLine("}");
        }

        // ファイル名: {クラス名}InjectParams.cs
        string fileName = $"{className}InjectParams.cs";
        string fullPath = Path.Combine(outputPath, fileName);
        
        // ファイル内容に変更がないかチェック
        string newContent = sb.ToString();
        if (ShouldSkipFileGeneration(fullPath, newContent))
        {
            Debug.Log($"Skipping {fileName} - no changes detected");
            return false;
        }
        
        File.WriteAllText(fullPath, newContent);
        Debug.Log($"Generated {fileName}");
        return true;
    }

    /// <summary>
    /// InjectParamListのPartial Classを生成
    /// </summary>
    /// <returns>ファイルが生成された場合はtrue、スキップされた場合はfalse</returns>
    private static bool GenerateInjectParamListPartialClass(string outputPath, ParamInjectSettings settings, List<Type> types)
    {
        var sb = new StringBuilder();

        // 必要なusing句を収集
        var requiredNamespaces = new HashSet<string>();
        requiredNamespaces.Add("UnityEngine");
        requiredNamespaces.Add("System.Collections.Generic");

        // 注入可能な型から必要なnamespaceを収集
        foreach (var fieldType in types)
        {
            var fields = fieldType.GetFields(System.Reflection.BindingFlags.Instance |
                                      System.Reflection.BindingFlags.Public |
                                      System.Reflection.BindingFlags.NonPublic);

            foreach (var field in fields)
            {
                var injectAttr = field.GetCustomAttribute<InjectAttribute>();
                if (injectAttr != null)
                {
                    CollectRequiredNamespaces(field.FieldType, requiredNamespaces);
                }
            }
        }

        // ヘッダー
        sb.AppendLine("// ========== AUTO GENERATED CODE ==========");
        sb.AppendLine("// Generated at: " + DateTime.Now);
        sb.AppendLine("// DO NOT EDIT THIS FILE MANUALLY");
        sb.AppendLine();

        // using句を追加
        foreach (var ns in requiredNamespaces.OrderBy(x => x))
        {
            sb.AppendLine($"using {ns};");
        }
        sb.AppendLine();

        sb.AppendLine("// ========== InjectParamList Partial Class (Auto Generated) ==========");
        sb.AppendLine();
        sb.AppendLine("public partial class InjectParamList");
        sb.AppendLine("{");
        var processedFields = new Dictionary<string, object>(); // 重複を避けるため、デフォルト値も保持
        
        foreach (var type in types)
        {
            var fields = type.GetFields(System.Reflection.BindingFlags.Instance | 
                                      System.Reflection.BindingFlags.Public | 
                                      System.Reflection.BindingFlags.NonPublic);
            
            foreach (var field in fields)
            {
                var injectAttr = field.GetCustomAttribute<InjectAttribute>();
                if (injectAttr != null)
                {
                    string key = injectAttr.Key ?? field.Name;
                    if (string.IsNullOrEmpty(injectAttr.Key) && key.StartsWith("_"))
                    {
                        key = key.Substring(1);
                    }
                    
                    // 同じ名前のフィールドは一度だけ生成、最初に見つけたデフォルト値を使用
                    if (processedFields.ContainsKey(key))
                        continue;
                    
                    // デフォルト値を取得
                    object defaultValue = GetDefaultValueFromField(type, field);
                    processedFields.Add(key, defaultValue);
                    
                    string fieldTypeName = GetTypeName(field.FieldType);
                    // UpperCamelCaseに変換
                    string propertyName = ToUpperCamelCase(key);
                    string defaultValueString = FormatDefaultValue(defaultValue, field.FieldType);
                    
                    sb.AppendLine($"    [SerializeField] private {fieldTypeName} _{key} = {defaultValueString};");
                    sb.AppendLine($"    public {fieldTypeName} {propertyName} => _{key};");
                    sb.AppendLine();
                }
            }
        }
        
        sb.AppendLine("}");
        sb.AppendLine();

        // ファイル名: InjectParamListParams.cs
        string fullPath = Path.Combine(outputPath, INJECT_PARAM_LIST_FILE_NAME);
        
        // ファイル内容に変更がないかチェック
        string newContent = sb.ToString();
        if (ShouldSkipFileGeneration(fullPath, newContent))
        {
            Debug.Log($"Skipping {INJECT_PARAM_LIST_FILE_NAME} - no changes detected");
            return false;
        }
        
        File.WriteAllText(fullPath, newContent);
        Debug.Log($"Generated {INJECT_PARAM_LIST_FILE_NAME}");
        return true;
    }

    /// <summary>
    /// 注入可能な型を検索
    /// </summary>
    public static List<Type> FindInjectableTypes()
    {
        var types = new List<Type>();

        foreach (var assembly in AppDomain.CurrentDomain.GetAssemblies())
        {
            try
            {
                foreach (var type in assembly.GetTypes())
                {
                    if (type.IsAbstract || type.IsInterface) continue;

                    var fields = type.GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
                    bool hasInjectField = fields.Any(f => f.GetCustomAttribute<InjectAttribute>() != null);

                    if (hasInjectField)
                    {
                        types.Add(type);
                        Debug.Log($"DICodeGenerator: Found injectable type {type.FullName}");
                    }
                }
            }
            catch (Exception e)
            {
                // アセンブリ読み込みエラーを無視（リフレクション系の例外は正常）
                Debug.LogWarning($"DICodeGenerator: Could not scan assembly {assembly.FullName}: {e.Message}");
            }
        }

        return types;
    }

    private static string GetTypeName(Type type)
    {
        if (type == typeof(int)) return "int";
        if (type == typeof(float)) return "float";
        if (type == typeof(string)) return "string";
        if (type == typeof(bool)) return "bool";
        if (type == typeof(double)) return "double";

        // ジェネリック型の処理
        if (type.IsGenericType)
        {
            return GetGenericTypeName(type);
        }

        // アセンブリ修飾名を含まない型名を返す
        return type.Name;
    }

    /// <summary>
    /// ジェネリック型名を生成
    /// </summary>
    private static string GetGenericTypeName(Type type)
    {
        if (!type.IsGenericType)
            return type.Name;

        var genericTypeName = type.Name.Split('`')[0]; // List`1 -> List
        var genericArgs = type.GetGenericArguments();
        var argNames = genericArgs.Select(GetTypeName);

        return $"{genericTypeName}<{string.Join(", ", argNames)}>";
    }

    /// <summary>
    /// 文字列をUpperCamelCaseに変換
    /// </summary>
    private static string ToUpperCamelCase(string input)
    {
        if (string.IsNullOrEmpty(input))
            return input;

        // 最初の文字を大文字に
        return char.ToUpper(input[0]) + input.Substring(1);
    }

    /// <summary>
    /// 指定されたクラスのフィールドからデフォルト値を取得
    /// </summary>
    private static object GetDefaultValueFromField(Type type, FieldInfo field)
    {
        try
        {
            // クラスのインスタンスを作成してデフォルト値を取得
            object instance = Activator.CreateInstance(type);
            return field.GetValue(instance);
        }
        catch (Exception e)
        {
            Debug.LogWarning($"DICodeGenerator: Could not get default value for {type.Name}.{field.Name}: {e.Message}");
            
            // フォールバック: 型のデフォルト値を返す
            if (field.FieldType.IsValueType)
            {
                return Activator.CreateInstance(field.FieldType);
            }
            return null;
        }
    }

    /// <summary>
    /// デフォルト値をC#コード形式の文字列に変換
    /// </summary>
    private static string FormatDefaultValue(object value, Type fieldType)
    {
        if (value == null)
        {
            return "default";
        }

        if (fieldType == typeof(string))
        {
            return $"\"{value}\"";
        }
        else if (fieldType == typeof(bool))
        {
            return value.ToString().ToLower();
        }
        else if (fieldType == typeof(float))
        {
            return $"{value}f";
        }
        else if (fieldType == typeof(double))
        {
            return $"{value}d";
        }
        else if (fieldType == typeof(Vector3))
        {
            var v3 = (Vector3)value;
            return $"new UnityEngine.Vector3({v3.x}f, {v3.y}f, {v3.z}f)";
        }
        else if (fieldType == typeof(Vector2))
        {
            var v2 = (Vector2)value;
            return $"new UnityEngine.Vector2({v2.x}f, {v2.y}f)";
        }
        else if (fieldType == typeof(Color))
        {
            var color = (Color)value;
            return $"new UnityEngine.Color({color.r}f, {color.g}f, {color.b}f, {color.a}f)";
        }
        else if (fieldType.IsEnum)
        {
            return $"{fieldType.Name}.{value}";
        }
        else if (fieldType.IsValueType)
        {
            return value.ToString();
        }
        
        return "default";
    }

    /// <summary>
    /// ファイル生成をスキップするかどうか判定
    /// </summary>
    /// <param name="filePath">ファイルパス</param>
    /// <param name="newContent">新しいファイル内容</param>
    /// <returns>スキップする場合はtrue</returns>
    private static bool ShouldSkipFileGeneration(string filePath, string newContent)
    {
        // ファイルが存在しない場合は生成する
        if (!File.Exists(filePath))
        {
            return false;
        }

        try
        {
            // 既存ファイルの内容を読み込み
            string existingContent = File.ReadAllText(filePath);
            
            // 日付部分を除去して比較（Generated at: の行を無視）
            string normalizedExisting = NormalizeContentForComparison(existingContent);
            string normalizedNew = NormalizeContentForComparison(newContent);
            
            // 内容が同じ場合はスキップ
            return string.Equals(normalizedExisting, normalizedNew, StringComparison.Ordinal);
        }
        catch (Exception e)
        {
            Debug.LogWarning($"DICodeGenerator: Could not compare file content for {filePath}: {e.Message}");
            // エラーが発生した場合は安全のため生成する
            return false;
        }
    }

    /// <summary>
    /// 比較用にコンテンツを正規化（日付情報を除去）
    /// </summary>
    /// <param name="content">ファイル内容</param>
    /// <returns>正規化された内容</returns>
    private static string NormalizeContentForComparison(string content)
    {
        if (string.IsNullOrEmpty(content))
        {
            return content;
        }

        var lines = content.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
        var normalizedLines = new List<string>();

        foreach (var line in lines)
        {
            // "Generated at:" の行をスキップ
            if (line.Trim().StartsWith("// Generated at:"))
            {
                continue;
            }
            normalizedLines.Add(line);
        }

        return string.Join("\n", normalizedLines);
    }

    /// <summary>
    /// 型から必要なnamespaceを収集
    /// </summary>
    private static void CollectRequiredNamespaces(Type type, HashSet<string> namespaces)
    {
        // 基本型はusing不要
        if (type.IsPrimitive || type == typeof(string) || type == typeof(object))
            return;

        // UnityEngine型は既に追加済み
        if (!string.IsNullOrEmpty(type.Namespace) &&
            !type.Namespace.StartsWith("UnityEngine") &&
            !type.Namespace.StartsWith("System.Collections.Generic"))
        {
            namespaces.Add(type.Namespace);
        }

        // ジェネリック型の型引数も処理
        if (type.IsGenericType)
        {
            foreach (var genericArg in type.GetGenericArguments())
            {
                CollectRequiredNamespaces(genericArg, namespaces);
            }
        }

        // 配列型の要素型も処理
        if (type.IsArray)
        {
            CollectRequiredNamespaces(type.GetElementType(), namespaces);
        }
    }

    /// <summary>
    /// ファイル内容のハッシュ値を計算（デバッグ用）
    /// </summary>
    /// <param name="content">ファイル内容</param>
    /// <returns>SHA256ハッシュ値</returns>
    private static string CalculateContentHash(string content)
    {
        using (var sha256 = SHA256.Create())
        {
            byte[] bytes = Encoding.UTF8.GetBytes(content);
            byte[] hash = sha256.ComputeHash(bytes);
            return Convert.ToBase64String(hash);
        }
    }
}

// カスタムビルドプロセッサー
public class DIBuildProcessor : UnityEditor.Build.IPreprocessBuildWithReport
{
    public int callbackOrder => 0;

    public void OnPreprocessBuild(UnityEditor.Build.Reporting.BuildReport report)
    {
        Debug.Log("Generating DI injection code before build...");
        DICodeGenerator.GenerateInjectionCode();
    }
}

#endif